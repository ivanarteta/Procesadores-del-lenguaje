# Autores
Iván Arteta, Íñigo Fernández y Maider Pérez

## Compilación
Para compilar los programas
```
make all
```
Para eliminar los archivos que se han creado
```
make clean
```
Para ejecutar el programa con cualquiera de los 3 ficheros (programaX.alg)
```
./a.out programaX.alg
```

## Decisiones tomadas en Bison con Fitxi
Ante la ambigüedad intrínseca de las expresiones aritmeticas y booleanas, hemos acordado usar el método **1º GII**. Este método consiste en cargarnos la producción operando en la expresión booleana.

## Curiosidades
Como nos hemos basado en una página web para asignar las prioridades a los operadores en la parte de Bison, queremos que quede constancia de donde los hemos sacado. Se puede consultar la web mediante el siguiente enlace: [prioridades operadores](https://docs.microsoft.com/es-es/dotnet/visal-basic/language-reference/operators/operator-precedence)


## Decisiones tomadas en grupo

### Introducir los identificadores/variables a la TS
Partiendo de la siguiente gramática a la hora de añadir los identificadores/variables a la TS, nos hemos encontrado con los siguientes problemas:

```
lista_definiciones_var: lista_id TK_DEF_TIPO def_tipo TK_COMPOSICION_SECUENCIAL lista_definiciones_var 
                        | /* vacio */
                        ;
lista_id:   TK_IDENTIFICADOR TK_SEPARADOR lista_id 
            | TK_IDENTIFICADOR
            | /* vacio */
            ;
```

1. Si añadimos primero a la TS los nombres de los identificadores/variables (desde lista_id), al llegar a lista_definiciones_var para añadir los tipos, no podemos acceder a todos los TK_IDENTIFICADOR, por ejemplo, con *ent a,b:entero;* en lista_definiciones_var sólo podríamos ver el identificador "a" con $1. Por lo que habría muchos identificadores en la TS que no tuviesen asignado un tipo.

2. Si añadimos desde lista_definiciones_var simultaneamente el nombre del identificador y el tipo, siempre que hubiese una lista de identificadores separados por comas, solamente se añadiría el primero, por lo que la TS estaría incompleta.

**Solución**: Desde la única parte que hemos visto que podemos acceder a todos los identificadores, es desde lista_id, por lo que teníamos claro que desde aquí teníamos que introducir en la TS tanto el nombre como el tipo de cada uno de ellos. Por lo que, teniamos que buscar la manera de poder acceder a def_tipo desde aquí. Por lo que, hemos realizado una modificación en esas dos expresiones de forma que el nuevo codigo queda de la siguiente forma:
```
lista_definiciones_var: lista_id TK_COMPOSICION_SECUENCIAL lista_definiciones_var 
                        | /* vacio */
                        ;
lista_id:   TK_IDENTIFICADOR TK_SEPARADOR lista_id 
            | TK_IDENTIFICADOR TK_DEF_TIPO def_tipo
            ;
```
(Para poder acceder desde la primera producción de lista_id al tipo, en la segunda producción hemos tenido que poner $$ = $3)

### Introducir las expresiones booleanas a la TC
Para introducir las expresiones booleanas, hemos tenido que redefinir algunas funciones tal y como aparecían en los apuntes. Es decir, en algunos puntos concretos hemos tenido que introducir una nueva variable M.
Por lo que partiendo de nuestra gramática original:
```
expresion_booleana: expresion_booleana TK_Y expresion_booleana
                    | expresion_booleana TK_O expresion_booleana
                    | TK_NO expresion_booleana
                    | TK_LITERAL_BOOLEANO
                    | expresion_aritmetica TK_OPERADOR_RELACIONAL expresion_aritmetica
                    | expresion_aritmetica TK_IGUAL expresion_aritmetica
                    | TK_INICIO_PARENTESIS expresion_booleana TK_FIN_PARENTESIS
                    ;
```
Hemos modificado la gramática añadiendole la variable M, de forma que la nueva gramática sea la siguiente:
```
expresion_booleana: expresion_booleana TK_Y M expresion_booleana
                    | expresion_booleana TK_O M expresion_booleana
                    | TK_NO expresion_booleana
                    | TK_LITERAL_BOOLEANO
                    | expresion_aritmetica TK_OPERADOR_RELACIONAL expresion_aritmetica
                    | expresion_aritmetica TK_IGUAL expresion_aritmetica
                    | TK_INICIO_PARENTESIS expresion_booleana TK_FIN_PARENTESIS
                    ;
```
Esta variable M se utilizará también en otros sitios, como por ejemplo los bucles. Para indicar el lugar a donde se realiza el salto.

### Campos de la TC
En un principio teniamos los 4 campos (operador, operando1, operando2 y resultado) como enteros ya que se supone que nos indican que elemento de la TS tiene el valor en tiempo de ejecución. 
En nuestro caso, hemos decidido que los dos operandos y el resultado, como son variables, hemos cambiado el tipo de int a char* para almacenar su identificador.


### Introducir las constantes a la TS
Hemos partido de la siguiente gramática a la hora de ir a introducir las constantes en la TS:
```
lista_definiciones_const:   TK_IDENTIFICADOR TK_IGUAL TK_LITERAL_ENTERO TK_COMPOSICION_SECUENCIAL lista_definiciones_const
                            | TK_IDENTIFICADOR TK_IGUAL TK_LITERAL_REAL TK_COMPOSICION_SECUENCIAL lista_definiciones_const 
                            | TK_IDENTIFICADOR TK_IGUAL TK_LITERAL_CADENA TK_COMPOSICION_SECUENCIAL lista_definiciones_const 
                            | TK_IDENTIFICADOR TK_IGUAL TK_LITERAL_CARACTER TK_COMPOSICION_SECUENCIAL lista_definiciones_const 
                            | TK_IDENTIFICADOR TK_IGUAL TK_VERDADERO TK_COMPOSICION_SECUENCIAL lista_definiciones_const
                            | TK_IDENTIFICADOR TK_IGUAL TK_FALSO TK_COMPOSICION_SECUENCIAL lista_definiciones_const  
                            | /* vacio */ 
```
Hemos visto que en cada una de ellas teníamos que llamar a la función TS_insertar_constante, por lo que hemos buscado una alternativa para no tener que escribirlo tantas veces, y que posteriormente nos puede venir bien. Por lo que hemos creado una nueva regla que sea para los literales, de la misma forma que tenemos definido tipo_base. Por lo que la nueva gramática queda tal que así:
```
lista_definiciones_const:   TK_IDENTIFICADOR TK_IGUAL tipo_literal TK_COMPOSICION_SECUENCIAL lista_definiciones_const 
                            | /* vacio */ 
                            ;
tipo_literal:   TK_LITERAL_CADENA 
                | TK_LITERAL_CARACTER 
                | TK_LITERAL_ENTERO 
                | TK_LITERAL_REAL 
                | TK_LITERAL_BOOLEANO
                ;
```
### Introducir los datos del bucle PARA en la TC
En un principio hemos usado la siguiente gramática:
```
it_cota_fija:   TK_PARA M TK_IDENTIFICADOR TK_ASIGNACION expresion TK_HASTA expresion TK_HACER instrucciones TK_FPARA
```
El problema es que primero se nos añadían a la TC los campos de las instrucciones y posteriormente el de la asignacion del para. Por lo que para controlar eso y que primero se añadan los de la asignacion y por último se añadan los de las instrucciones, hemos modificado la gramática, de forma que quede tal que:
```
it_cota_fija:   M it_cota instrucciones TK_FPARA

it_cota: TK_PARA M asignacion TK_HASTA expresion TK_HACER

```
De esta forma el código queda más reducido y el funcionamiento es el esperado.

### Introducir acciones y funciones
Hemos introducido acciones y funciones sin meternos en la llamada a las mismas. El resultado es que metemos los identificadores de los parámetros de entrada/salida junto su tipo de paso en la TS. De forma que el identificador es la posición en la TS del parámetro que se pasa y el tipo de paso es un entero con los siguientes valores:

---
1 | Parámetro de entrada

---
2 | Parámetro de salida

---
3 | Parmámetro de entrada/salida

---
4 | Parámetro devuelto por una función

---
El código de dentro de las acciones y funciones (los bloques), se leen y se añaden a las tablas igual que el de un algoritmo normal, salvo las partes de input y output, que se opera con ellas con la información de la TS referente a su id y tipo de paso. Los inputs y outputs que se ven son los del algoritmo.